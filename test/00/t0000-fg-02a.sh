#!/bin/sh
#
# aegis - project change supervisor.
# Copyright (C) 2008, 2011, 2012 Peter Miller
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.
#

TEST_SUBJECT="fmtgen, top level"

# load up standard prelude and test functions
. test_funcs

cat > fubar.def << 'fubar'
x = integer;
fubar
if test $? -ne 0 ; then no_result; fi

cat > ok << 'TheEnd'
//
// This file is generated by fmtgen.
//
#include <fubar.h>
#include <common/trace.h>
#include <libaegis/io.h>
#include <common/ac/assert.h>
#include <common/sizeof.h>
#include <libaegis/output.h>

void
fubar_write(const output::pointer &fp, fubar_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fubar_write(this_thing = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fubar_ty *)this_thing)->reference_count));
  integer_write(fp, "x", this_thing->x, 0);
  trace(("}\n"));
}

void
fubar_write_xml(const output::pointer &fp, fubar_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fubar_write_xml(this_thing = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fubar_ty *)this_thing)->reference_count));
  fp->fputs("<fubar>\n");
  integer_write_xml(fp, "x", this_thing->x, 0);
  fp->fputs("</fubar>\n");
}
#include <common/mem.h>
#include <libaegis/meta_lex.h>

static void *
fubar_alloc(void)
{
  fubar_ty *this_thing;

  trace(("fubar_alloc()\n{\n"));
  this_thing = (fubar_ty *)mem_alloc(sizeof(fubar_ty));
  this_thing->reference_count = 1;
  this_thing->mask = 0;
  this_thing->errpos = str_copy(lex_position());
  this_thing->x = (long)0;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fubar_ty *
fubar_copy(fubar_ty *this_thing)
{
  trace(("fubar_copy()\n{\n"));
  this_thing->reference_count++;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fubar_ty *
fubar_clone(fubar_ty *this_thing)
{
  if (!this_thing)
    return 0;
  trace(("fubar_clone()\n{\n"));
  fubar_ty *result = (fubar_ty *)fubar_alloc();
  result->x = this_thing->x;
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

#ifdef DEBUG

void
fubar_trace_real(const char *name, const fubar_ty *value)
{
  if (name && *name)
  {
    trace_printf("%s = ", name);
  }
  if (!value)
  {
    trace_printf("NULL");
  }
  else
  {
    trace_printf("{\n");
    trace_long_real("x", &value->x);
    trace_printf("}");
  }
  trace_printf((name && *name) ? ";\n" : ",\n");
}

#endif // DEBUG

static void
fubar_free(void *that)
{
  fubar_ty *this_thing;

  this_thing = (fubar_ty *)that;
  if (!this_thing)
    return;
  this_thing->reference_count--;
  assert(this_thing->reference_count >= 0);
  if (this_thing->reference_count > 0)
    return;
  trace(("fubar_free(this_thing = %p)\n{\n", this_thing));
  if (this_thing->errpos)
  {
    str_free(this_thing->errpos);
    this_thing->errpos = 0;
  }
  mem_free(this_thing);
  trace(("}\n"));
}

static type_table_ty fubar_table[] =
{
  {
    "x",
    offsetof(fubar_ty, x),
    &integer_type,
    fubar_x_mask,
    0, // redefinition not ok
    0, // fast_name
  },
};

static void *
fubar_parse(void *this_thing, string_ty *name, meta_type **type_pp, unsigned long *mask_p, int *redef_p)
{
  void *addr;

  trace(("fubar_parse(this_thing = %p, name = %p, type_pp = %p)\n{\n", this_thing, name, type_pp));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  addr =
    generic_struct_parse
    (
      this_thing,
      name,
      type_pp,
      mask_p,
      redef_p,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n}\n", addr));
  return addr;
}

static string_ty *
fubar_fuzzy(string_ty *name)
{
  string_ty *result;

  trace(("fubar_fuzzy(name = %p)\n{\n", name));
  result =
    generic_struct_fuzzy
    (
      name,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

static rpt_value::pointer
fubar_convert(void *this_thing)
{
  trace(("fubar_convert(name = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  rpt_value::pointer result =
    generic_struct_convert
    (
      this_thing,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n", result.get()));
  trace(("}\n"));
  return result;
}

meta_type fubar_type =
{
  "fubar",
  fubar_alloc,
  fubar_free,
  0, // enum_parse
  0, // list_parse
  fubar_parse,
  fubar_fuzzy,
  fubar_convert,
  generic_struct_is_set,
};

fubar_ty *
fubar_read_file(const nstring &filename)
{
  return fubar_read_file(filename.get_ref());
}
#include <libaegis/meta_parse.h>
#include <libaegis/os.h>

fubar_ty *
fubar_read_file(string_ty *filename)
{
  fubar_ty *result;

  trace(("fubar_read_file(filename = \"%s\")\n{\n", (filename ? filename->str_text : "")));
  os_become_must_be_active();
  result = (fubar_ty *)parse(filename, &fubar_type);
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

void
fubar_write_file(const nstring &filename, fubar_ty *value, bool comp)
{
  fubar_write_file(filename.get_ref(), value, comp);
}
#include <libaegis/output/file.h>
#include <libaegis/output/filter/gzip.h>
#include <libaegis/output/filter/indent.h>

void
fubar_write_file(string_ty *filename, fubar_ty *value, int needs_compression)
{
  trace(("fubar_write_file(filename = \"%s\", value = %p)\n{\n", (filename ? filename->str_text : ""), value));
  if (filename)
    os_become_must_be_active();
  output::pointer fp;
  if (needs_compression)
  {
    fp = output_file::binary_open(filename);
    fp = output_filter_gzip::create(fp);
  }
  else
  {
    fp = output_file::text_open(filename);
  }
  fp = output_filter_indent::create(fp);
  io_comment_emit(fp);
  fubar_write(fp, value);
  type_enum_option_clear();
  trace(("}\n"));
}

void
fubar__rpt_init(void)
{
  trace(("fubar__rpt_init()\n{\n"));
  trace(("}\n"));
}
TheEnd
if test $? -ne 0 ; then no_result; fi

#
# test the functionality
#
activity="fmtgen-oc 299"
fmtgen -tw=2 fubar.def -oc fubar.cc
if test $? -ne 0 ; then fail; fi

diff ok fubar.cc
if test $? -ne 0 ; then fail; fi

#
# Only definite negatives are possible.
# The functionality exercised by this test appears to work,
# no other guarantees are made.
#
pass
# vim: set ts=8 sw=4 et :
