#!/bin/sh
#
# aegis - project change supervisor.
# Copyright (C) 2008, 2011, 2012 Peter Miller
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.
#

TEST_SUBJECT="fmtgen, enum"

# load up standard prelude and test functions
. test_funcs

cat > fubar.def << 'fubar'
x = (one, two, three);
fubar
if test $? -ne 0 ; then no_result; fi

cat > ok.cc << 'TheEnd'
//
// This file is generated by fmtgen.
//
#include <fubar.h>
#include <common/sizeof.h>

static const char *fubar_x_s[] =
{
  "one",
  "two",
  "three",
};
static string_ty *fubar_x_f[SIZEOF(fubar_x_s)];
#include <common/ac/stdio.h>

const char *
fubar_x_ename(fubar_x_ty this_thing)
{
  static char buffer[20];

  if ((int)this_thing >= 0 && (int)this_thing < 3)
    return fubar_x_s[this_thing];
  snprintf(buffer, sizeof(buffer), "%d", (int)this_thing);
  return buffer;
}

void
fubar_x_write(const output::pointer &fp, const char *name, fubar_x_ty this_thing, bool show)
{
  if (this_thing == 0)
  {
    if (!show || type_enum_option_query())
      return;
  }
  if (name)
  {
    fp->fputs(name);
    fp->fputs(" = ");
  }
  fp->fputs(fubar_x_s[this_thing]);
  if (name)
    fp->fputs(";\n");
}
#include <common/ac/assert.h>

void
fubar_x_write_xml(const output::pointer &fp, const char *name, fubar_x_ty this_thing, bool show)
{
  if (this_thing == 0)
  {
    if (!show || type_enum_option_query())
      return;
  }
  assert(name);
  assert(this_thing < fubar_x_max);
  fp->fputc('<');
  fp->fputs(name);
  fp->fputc('>');
  fp->fputs(fubar_x_s[this_thing]);
  fp->fputs("</");
  fp->fputs(name);
  fp->fputs(">\n");
}
#include <common/str.h>

static bool
fubar_x_parse(string_ty *name, void *ptr)
{
  slow_to_fast(fubar_x_s, fubar_x_f, SIZEOF(fubar_x_s));
  for (size_t j = 0; j < SIZEOF(fubar_x_f); ++j)
  {
    if (str_equal(name, fubar_x_f[j]))
    {
      *(fubar_x_ty *)ptr = (fubar_x_ty)j;
      return true;
    }
  }
  return false;
}
#include <libaegis/meta_type.h>

static string_ty *
fubar_x_fuzzy(string_ty *name)
{
  return generic_enum_fuzzy(name, fubar_x_f, SIZEOF(fubar_x_f));
}

static rpt_value::pointer
fubar_x_convert(void *this_thing)
{
  if (!fubar_x_f[0])
    slow_to_fast(fubar_x_s, fubar_x_f, SIZEOF(fubar_x_s));
  return
    generic_enum_convert
    (
      (int)*(fubar_x_ty *)this_thing,
      fubar_x_f,
      SIZEOF(fubar_x_f)
    );
}

static bool
fubar_x_is_set(void *this_thing)
{
  return (*(fubar_x_ty *)this_thing != 0);
}

meta_type fubar_x_type =
{
  "fubar_x",
  0, // alloc
  0, // free
  fubar_x_parse,
  0, // list_parse
  0, // struct_parse
  fubar_x_fuzzy,
  fubar_x_convert,
  fubar_x_is_set,
};

void
fubar_x__rpt_init()
{
  generic_enum__init(fubar_x_s, SIZEOF(fubar_x_s));
}
#include <common/trace.h>
#include <libaegis/output.h>

void
fubar_write(const output::pointer &fp, fubar_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fubar_write(this_thing = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fubar_ty *)this_thing)->reference_count));
  fubar_x_write(fp, "x", this_thing->x, 1);
  trace(("}\n"));
}

void
fubar_write_xml(const output::pointer &fp, fubar_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fubar_write_xml(this_thing = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fubar_ty *)this_thing)->reference_count));
  fp->fputs("<fubar>\n");
  fubar_x_write_xml(fp, "x", this_thing->x, 0);
  fp->fputs("</fubar>\n");
}
#include <common/mem.h>
#include <libaegis/meta_lex.h>

static void *
fubar_alloc(void)
{
  fubar_ty *this_thing;

  trace(("fubar_alloc()\n{\n"));
  this_thing = (fubar_ty *)mem_alloc(sizeof(fubar_ty));
  this_thing->reference_count = 1;
  this_thing->mask = 0;
  this_thing->errpos = str_copy(lex_position());
  this_thing->x = (fubar_x_ty)0;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fubar_ty *
fubar_copy(fubar_ty *this_thing)
{
  trace(("fubar_copy()\n{\n"));
  this_thing->reference_count++;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fubar_ty *
fubar_clone(fubar_ty *this_thing)
{
  if (!this_thing)
    return 0;
  trace(("fubar_clone()\n{\n"));
  fubar_ty *result = (fubar_ty *)fubar_alloc();
  result->x = this_thing->x;
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

#ifdef DEBUG

void
fubar_trace_real(const char *name, const fubar_ty *value)
{
  if (name && *name)
  {
    trace_printf("%s = ", name);
  }
  if (!value)
  {
    trace_printf("NULL");
  }
  else
  {
    trace_printf("{\n");
    trace_printf("x = %s;\n", fubar_x_ename(value->x));
    trace_printf("}");
  }
  trace_printf((name && *name) ? ";\n" : ",\n");
}

#endif // DEBUG

static void
fubar_free(void *that)
{
  fubar_ty *this_thing;

  this_thing = (fubar_ty *)that;
  if (!this_thing)
    return;
  this_thing->reference_count--;
  assert(this_thing->reference_count >= 0);
  if (this_thing->reference_count > 0)
    return;
  trace(("fubar_free(this_thing = %p)\n{\n", this_thing));
  if (this_thing->errpos)
  {
    str_free(this_thing->errpos);
    this_thing->errpos = 0;
  }
  mem_free(this_thing);
  trace(("}\n"));
}

static type_table_ty fubar_table[] =
{
  {
    "x",
    offsetof(fubar_ty, x),
    &fubar_x_type,
    fubar_x_mask,
    0, // redefinition not ok
    0, // fast_name
  },
};

static void *
fubar_parse(void *this_thing, string_ty *name, meta_type **type_pp, unsigned long *mask_p, int *redef_p)
{
  void *addr;

  trace(("fubar_parse(this_thing = %p, name = %p, type_pp = %p)\n{\n", this_thing, name, type_pp));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  addr =
    generic_struct_parse
    (
      this_thing,
      name,
      type_pp,
      mask_p,
      redef_p,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n}\n", addr));
  return addr;
}

static string_ty *
fubar_fuzzy(string_ty *name)
{
  string_ty *result;

  trace(("fubar_fuzzy(name = %p)\n{\n", name));
  result =
    generic_struct_fuzzy
    (
      name,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

static rpt_value::pointer
fubar_convert(void *this_thing)
{
  trace(("fubar_convert(name = %p)\n{\n", this_thing));
  assert(((fubar_ty *)this_thing)->reference_count > 0);
  rpt_value::pointer result =
    generic_struct_convert
    (
      this_thing,
      fubar_table,
      SIZEOF(fubar_table)
    );
  trace(("return %p;\n", result.get()));
  trace(("}\n"));
  return result;
}

meta_type fubar_type =
{
  "fubar",
  fubar_alloc,
  fubar_free,
  0, // enum_parse
  0, // list_parse
  fubar_parse,
  fubar_fuzzy,
  fubar_convert,
  generic_struct_is_set,
};

fubar_ty *
fubar_read_file(const nstring &filename)
{
  return fubar_read_file(filename.get_ref());
}
#include <libaegis/meta_parse.h>
#include <libaegis/os.h>

fubar_ty *
fubar_read_file(string_ty *filename)
{
  fubar_ty *result;

  trace(("fubar_read_file(filename = \"%s\")\n{\n", (filename ? filename->str_text : "")));
  os_become_must_be_active();
  result = (fubar_ty *)parse(filename, &fubar_type);
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

void
fubar_write_file(const nstring &filename, fubar_ty *value, bool comp)
{
  fubar_write_file(filename.get_ref(), value, comp);
}
#include <libaegis/io.h>
#include <libaegis/output/file.h>
#include <libaegis/output/filter/gzip.h>
#include <libaegis/output/filter/indent.h>

void
fubar_write_file(string_ty *filename, fubar_ty *value, int needs_compression)
{
  trace(("fubar_write_file(filename = \"%s\", value = %p)\n{\n", (filename ? filename->str_text : ""), value));
  if (filename)
    os_become_must_be_active();
  output::pointer fp;
  if (needs_compression)
  {
    fp = output_file::binary_open(filename);
    fp = output_filter_gzip::create(fp);
  }
  else
  {
    fp = output_file::text_open(filename);
  }
  fp = output_filter_indent::create(fp);
  io_comment_emit(fp);
  fubar_write(fp, value);
  type_enum_option_clear();
  trace(("}\n"));
}

void
fubar__rpt_init(void)
{
  trace(("fubar__rpt_init()\n{\n"));
  fubar_x__rpt_init();
  trace(("}\n"));
}
TheEnd
if test $? -ne 0 ; then no_result; fi

cat > ok.h << 'TheEnd'
//
// This file is generated by fmtgen.
//

#ifndef FUBAR_H
#define FUBAR_H
#include <libaegis/meta_type.h>
#include <libaegis/output.h>

#ifndef fubar_x_DEF
#define fubar_x_DEF
enum fubar_x_ty
{
  fubar_x_one,
  fubar_x_two,
  fubar_x_three
};
#define fubar_x_max 3
#endif // fubar_x_DEF

extern meta_type fubar_x_type;

void fubar_x_write(const output::pointer &fp, const char *name, fubar_x_ty value, bool show);
void fubar_x_write_xml(const output::pointer &fp, const char *name, fubar_x_ty value, bool show);
const char *fubar_x_ename(fubar_x_ty);
void fubar_x__rpt_init(void);

#ifndef fubar_DEF
#define fubar_DEF

#define fubar_x_mask  ((unsigned long)1 << 0)

#include <common/str.h>
struct fubar_ty
{
  long reference_count;
  unsigned long mask;
  string_ty *errpos;
  fubar_x_ty x;
};
#endif // fubar_DEF

extern meta_type fubar_type;

void fubar_write(const output::pointer &fp, fubar_ty *value);
void fubar_write_xml(const output::pointer &fp, fubar_ty *value);
fubar_ty *fubar_copy(fubar_ty *);
fubar_ty *fubar_clone(fubar_ty *);
#include <common/debug.h>
#ifndef fubar_trace
#ifdef DEBUG
void fubar_trace_real(const char *name, const fubar_ty *value);
#define fubar_trace(x) ((void)(trace_pretest_ && (trace_where_, fubar_trace_real(trace_stringize(x), x), 0)))
#else
#define fubar_trace(x)
#endif
#endif

/**
* The fubar_write_file function is used to
* write fubar meta data to the named file.
*
* @param filename
*     The name of the file to be written.
* @param value
*     The value of the meta-data to be written.
* @param comp
*     true (non-zero) if data should be compressed.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      will print a fatal error message, and
*      exit with an exit status of 1.
*/
void fubar_write_file(string_ty *filename, fubar_ty *value, int comp);
#include <common/nstring.h>

/**
* The fubar_write_file function is used to
* write fubar meta data to the named file.
*
* @param filnam
*     The name of the file to be written.
* @param value
*     The value of the meta-data to be written.
* @param comp
*     true if data should be compressed.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      will print a fatal error message, and
*      exit with an exit status of 1.
*/
void fubar_write_file(const nstring &filnam, fubar_ty *value, bool comp);

/**
* The fubar_read_file function is used to
* read fubar meta data from the named file.
*
* @param filename
*     The name of the file to be read.
* @returns
*     a pointer to a dynamically allocated
*     value read from the file.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      (including syntax errors) will print a
*      fatal error message, and exit with an
*      exit status of 1.
*/
fubar_ty *fubar_read_file(string_ty *filename);

/**
* The fubar_read_file function is used to
* read fubar meta data from the named file.
*
* @param filename
*     The name of the file to be read.
* @returns
*     a pointer to a dynamically allocated
*     value read from the file.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      (including syntax errors) will print a
*      fatal error message, and exit with an
*      exit status of 1.
*/
fubar_ty *fubar_read_file(const nstring &filename);
void fubar__rpt_init(void);

#endif // FUBAR_H
TheEnd
if test $? -ne 0 ; then no_result; fi

#
# test the functionality
#
activity="fmtgen-oc 546"
fmtgen -tw=2 fubar.def -oc fubar.cc -oi fubar.h
if test $? -ne 0 ; then fail; fi

diff ok.cc fubar.cc
if test $? -ne 0 ; then fail; fi

diff ok.h fubar.h
if test $? -ne 0 ; then fail; fi

#
# Only definite negatives are possible.
# The functionality exercised by this test appears to work,
# no other guarantees are made.
#
pass


// vim: set ts=8 sw=4 et :
