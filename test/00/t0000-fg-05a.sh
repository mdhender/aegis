#!/bin/sh
#
# aegis - project change supervisor.
# Copyright (C) 2008, 2011, 2012 Peter Miller
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.
#

TEST_SUBJECT="fmtgen, top-level"

# load up standard prelude and test functions
. test_funcs

cat > fred.def << 'fubar'
#include <incl.def>
f1 = t1;
f2 = t2;
fubar
if test $? -ne 0 ; then no_result; fi

cat > incl.def << 'fubar'
type t1 =
{
    t11 = integer;
    t12 = string;
};
type t2 = (red, green, blue);

first = [ integer ];

fubar
if test $? -ne 0 ; then no_result; fi

cat > ok.cc << 'fubar'
//
// This file is generated by fmtgen.
//
#include <fred.h>
#include <common/trace.h>
#include <libaegis/io.h>
#include <common/ac/assert.h>
#include <libaegis/aer/value/list.h>

void
fred_first_list_write(const output::pointer &fp, const char *name, fred_first_list_ty *this_thing)
{
  size_t j;

  if (!this_thing)
    return;
  trace(("fred_first_list_write(name = \"%s\", this_thing = %p)\n{\n", name, this_thing));
  if (name)
  {
    fp->fputs(name);
    fp->fputs(" =\n");
  }
  assert(this_thing->length <= this_thing->maximum);
  assert(!this_thing->list == !this_thing->maximum);
  fp->fputs("[\n");
  for (j = 0; j < this_thing->length; ++j)
  {
    integer_write(fp, (const char *)0, this_thing->list[j], 1);
    fp->fputs(",\n");
  }
  fp->fputs("]");
  if (name)
    fp->fputs(";\n");
  trace(("}\n"));
}

void
fred_first_list_write_xml(const output::pointer &fp, const char *name, fred_first_list_ty *this_thing)
{
  size_t j;

  if (!this_thing)
    return;
  trace(("fred_first_list_write_xml(name = \"%s\", this_thing = %p)\n{\n", name, this_thing));
  assert(name);
  fp->fputc('<');
  fp->fputs(name);
  fp->fputs(">\n");
  assert(this_thing->length <= this_thing->maximum);
  assert(!this_thing->list == !this_thing->maximum);
  for (j = 0; j < this_thing->length; ++j)
  {
    integer_write_xml(fp, "integer", this_thing->list[j], 1);
  }
  fp->fputs("</");
  fp->fputs(name);
  fp->fputs(">\n");
  trace(("}\n"));
}
#include <common/mem.h>

static void *
fred_first_list_alloc(void)
{
  fred_first_list_ty *result;

  trace(("fred_first_list_alloc()\n{\n"));
  result = (fred_first_list_ty *)mem_alloc(sizeof(fred_first_list_ty));
  result->list = 0;
  result->length = 0;
  result->maximum = 0;
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

static void
fred_first_list_free(void *that)
{
  fred_first_list_ty *this_thing;
  size_t j;

  this_thing = (fred_first_list_ty *)that;
  if (!this_thing)
    return;
  trace(("fred_first_list_free(this_thing = %p)\n{\n", this_thing));
  assert(this_thing->length <= this_thing->maximum);
  assert(!this_thing->list == !this_thing->maximum);
  for (j = 0; j < this_thing->length; ++j)
    ;
  delete [] this_thing->list;
  mem_free(this_thing);
  trace(("}\n"));
}

static void *
fred_first_list_parse(void *that, meta_type **type_pp)
{
  fred_first_list_ty *this_thing;
  void *addr;

  this_thing = (fred_first_list_ty *)that;
  trace(("fred_first_list_parse(this_thing = %p, type_pp = %p)\n{\n", this_thing, type_pp));
  assert(this_thing->length <= this_thing->maximum);
  assert(!this_thing->list == !this_thing->maximum);
  *type_pp = &integer_type;
  trace_pointer(*type_pp);
  if (this_thing->length >= this_thing->maximum)
  {
    this_thing->maximum = this_thing->maximum * 2 + 16;
    long *new_list = new long [this_thing->maximum];
    for (size_t j = 0; j < this_thing->length; ++j)
      new_list[j] = this_thing->list[j];
    delete [] this_thing->list;
    this_thing->list = new_list;
  }
  addr = &this_thing->list[this_thing->length++];
  trace(("return %p;\n", addr));
  trace(("}\n"));
  return addr;
}

static rpt_value::pointer
fred_first_list_convert(void *that)
{
  fred_first_list_ty *this_thing;
  size_t j;
  rpt_value::pointer vp;

  this_thing = *(fred_first_list_ty **)that;
  if (!this_thing)
    return rpt_value::pointer();
  trace(("fred_first_list_convert(this_thing = %p)\n{\n", this_thing));
  assert(this_thing->length <= this_thing->maximum);
  assert(!this_thing->list == !this_thing->maximum);
  rpt_value_list *p = new rpt_value_list();
  rpt_value::pointer result(p);
  for (j = 0; j < this_thing->length; ++j)
  {
    vp = integer_type.convert(&this_thing->list[j]);
    assert(vp);
    p->append(vp);
  }
  trace(("}\n"));
  trace(("return %p;\n", result.get()));
  return result;
}

fred_first_list_ty *
fred_first_list_copy(fred_first_list_ty *from)
{
  size_t j;
  fred_first_list_ty *result;

  if (!from)
    return 0;
  trace(("fred_first_list_copy(from = %p)\n{\n", from));
  result = (fred_first_list_ty *)fred_first_list_alloc();
  assert(from->length <= from->maximum);
  assert(!from->list == !from->maximum);
  for (j = 0; j < from->length; ++j)
  {
    long mp;
    long *mpp;
    meta_type *bogus;

    mp = from->list[j];
    mpp = (long*)fred_first_list_parse(result, &bogus);
    *mpp = integer_copy(mp);
  }
  trace(("return %8.8lX\n", (long)result));
  trace(("}\n"));
  return result;
}

fred_first_list_ty *
fred_first_list_clone(fred_first_list_ty *from)
{
  return fred_first_list_copy(from);
}

#ifdef DEBUG

void
fred_first_list_trace_real(const char *name, const fred_first_list_ty *value)
{
  if (name && *name)
  {
    trace_printf("%s = ", name);
  }
  if (!value)
  {
    trace_printf("NULL");
  }
  else
  {
    trace_printf("[\n");
    trace_printf("// length = %ld\n", (long)value->length);
    trace_printf("// maximum = %ld\n", (long)value->maximum);
    assert(value->length <= value->maximum);
    assert(!value->list == !value->maximum);
    for (size_t j = 0; j < value->length; ++j)
    {
      long mp = value->list[j];
      trace_long_real("", &mp);
    }
    trace_printf("]");
  }
  trace_printf((name && *name) ? ";\n" : ",\n");
}

#endif // DEBUG

meta_type fred_first_list_type =
{
  "fred_first_list",
  fred_first_list_alloc,
  fred_first_list_free,
  0, // enum_parse
  fred_first_list_parse,
  0, // struct_parse
  0, // fuzzy
  fred_first_list_convert,
  generic_struct_is_set,
};
#include <common/sizeof.h>
#include <libaegis/output.h>

void
fred_write(const output::pointer &fp, fred_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fred_write(this_thing = %p)\n{\n", this_thing));
  assert(((fred_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fred_ty *)this_thing)->reference_count));
  fred_first_list_write(fp, "first", this_thing->first);
  t1_write(fp, "f1", this_thing->f1);
  t2_write(fp, "f2", this_thing->f2, 1);
  trace(("}\n"));
}

void
fred_write_xml(const output::pointer &fp, fred_ty *this_thing)
{
  if (!this_thing)
    return;
  trace(("fred_write_xml(this_thing = %p)\n{\n", this_thing));
  assert(((fred_ty *)this_thing)->reference_count > 0);
  trace(("rc = %ld;\n", ((fred_ty *)this_thing)->reference_count));
  fp->fputs("<fred>\n");
  fred_first_list_write_xml(fp, "first", this_thing->first);
  t1_write_xml(fp, "f1", this_thing->f1);
  t2_write_xml(fp, "f2", this_thing->f2, 0);
  fp->fputs("</fred>\n");
}
#include <libaegis/meta_lex.h>

static void *
fred_alloc(void)
{
  fred_ty *this_thing;

  trace(("fred_alloc()\n{\n"));
  this_thing = (fred_ty *)mem_alloc(sizeof(fred_ty));
  this_thing->reference_count = 1;
  this_thing->mask = 0;
  this_thing->errpos = str_copy(lex_position());
  this_thing->first = (fred_first_list_ty *)0;
  this_thing->f1 = (t1_ty *)0;
  this_thing->f2 = (t2_ty)0;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fred_ty *
fred_copy(fred_ty *this_thing)
{
  trace(("fred_copy()\n{\n"));
  this_thing->reference_count++;
  trace(("return %p;\n", this_thing));
  trace(("}\n"));
  return this_thing;
}

fred_ty *
fred_clone(fred_ty *this_thing)
{
  if (!this_thing)
    return 0;
  trace(("fred_clone()\n{\n"));
  fred_ty *result = (fred_ty *)fred_alloc();
  result->first = fred_first_list_clone(this_thing->first);
  result->f1 = t1_clone(this_thing->f1);
  result->f2 = this_thing->f2;
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

#ifdef DEBUG

void
fred_trace_real(const char *name, const fred_ty *value)
{
  if (name && *name)
  {
    trace_printf("%s = ", name);
  }
  if (!value)
  {
    trace_printf("NULL");
  }
  else
  {
    trace_printf("{\n");
    fred_first_list_trace_real("first", value->first);
    t1_trace_real("f1", value->f1);
    trace_printf("f2 = %s;\n", t2_ename(value->f2));
    trace_printf("}");
  }
  trace_printf((name && *name) ? ";\n" : ",\n");
}

#endif // DEBUG

static void
fred_free(void *that)
{
  fred_ty *this_thing;

  this_thing = (fred_ty *)that;
  if (!this_thing)
    return;
  this_thing->reference_count--;
  assert(this_thing->reference_count >= 0);
  if (this_thing->reference_count > 0)
    return;
  trace(("fred_free(this_thing = %p)\n{\n", this_thing));
  if (this_thing->errpos)
  {
    str_free(this_thing->errpos);
    this_thing->errpos = 0;
  }
  fred_first_list_free(this_thing->first);
  t1_type.free(this_thing->f1);
  mem_free(this_thing);
  trace(("}\n"));
}

static type_table_ty fred_table[] =
{
  {
    "first",
    offsetof(fred_ty, first),
    &fred_first_list_type,
    fred_first_mask,
    0, // redefinition not ok
    0, // fast_name
  },
  {
    "f1",
    offsetof(fred_ty, f1),
    &t1_type,
    fred_f1_mask,
    0, // redefinition not ok
    0, // fast_name
  },
  {
    "f2",
    offsetof(fred_ty, f2),
    &t2_type,
    fred_f2_mask,
    0, // redefinition not ok
    0, // fast_name
  },
};

static void *
fred_parse(void *this_thing, string_ty *name, meta_type **type_pp, unsigned long *mask_p, int *redef_p)
{
  void *addr;

  trace(("fred_parse(this_thing = %p, name = %p, type_pp = %p)\n{\n", this_thing, name, type_pp));
  assert(((fred_ty *)this_thing)->reference_count > 0);
  addr =
    generic_struct_parse
    (
      this_thing,
      name,
      type_pp,
      mask_p,
      redef_p,
      fred_table,
      SIZEOF(fred_table)
    );
  trace(("return %p;\n}\n", addr));
  return addr;
}

static string_ty *
fred_fuzzy(string_ty *name)
{
  string_ty *result;

  trace(("fred_fuzzy(name = %p)\n{\n", name));
  result =
    generic_struct_fuzzy
    (
      name,
      fred_table,
      SIZEOF(fred_table)
    );
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

static rpt_value::pointer
fred_convert(void *this_thing)
{
  trace(("fred_convert(name = %p)\n{\n", this_thing));
  assert(((fred_ty *)this_thing)->reference_count > 0);
  rpt_value::pointer result =
    generic_struct_convert
    (
      this_thing,
      fred_table,
      SIZEOF(fred_table)
    );
  trace(("return %p;\n", result.get()));
  trace(("}\n"));
  return result;
}

meta_type fred_type =
{
  "fred",
  fred_alloc,
  fred_free,
  0, // enum_parse
  0, // list_parse
  fred_parse,
  fred_fuzzy,
  fred_convert,
  generic_struct_is_set,
};

fred_ty *
fred_read_file(const nstring &filename)
{
  return fred_read_file(filename.get_ref());
}
#include <libaegis/meta_parse.h>
#include <libaegis/os.h>

fred_ty *
fred_read_file(string_ty *filename)
{
  fred_ty *result;

  trace(("fred_read_file(filename = \"%s\")\n{\n", (filename ? filename->str_text : "")));
  os_become_must_be_active();
  result = (fred_ty *)parse(filename, &fred_type);
  trace(("return %p;\n", result));
  trace(("}\n"));
  return result;
}

void
fred_write_file(const nstring &filename, fred_ty *value, bool comp)
{
  fred_write_file(filename.get_ref(), value, comp);
}
#include <libaegis/output/file.h>
#include <libaegis/output/filter/gzip.h>
#include <libaegis/output/filter/indent.h>

void
fred_write_file(string_ty *filename, fred_ty *value, int needs_compression)
{
  trace(("fred_write_file(filename = \"%s\", value = %p)\n{\n", (filename ? filename->str_text : ""), value));
  if (filename)
    os_become_must_be_active();
  output::pointer fp;
  if (needs_compression)
  {
    fp = output_file::binary_open(filename);
    fp = output_filter_gzip::create(fp);
  }
  else
  {
    fp = output_file::text_open(filename);
  }
  fp = output_filter_indent::create(fp);
  io_comment_emit(fp);
  fred_write(fp, value);
  type_enum_option_clear();
  trace(("}\n"));
}

void
fred__rpt_init(void)
{
  trace(("fred__rpt_init()\n{\n"));
  t2__rpt_init();
  trace(("}\n"));
}
fubar
if test $? -ne 0 ; then no_result; fi

cat > ok.h << 'fubar'
//
// This file is generated by fmtgen.
//

#ifndef FRED_H
#define FRED_H
#include <common/str.h>

#ifndef t1_DEF
#define t1_DEF

#define t1_t11_mask ((unsigned long)1 << 0)
#define t1_t12_mask ((unsigned long)0)

struct t1_ty
{
  long reference_count;
  unsigned long mask;
  string_ty *errpos;
  long t11;
  string_ty *t12;
};
#endif // t1_DEF

#include <libaegis/meta_type.h>
extern meta_type t1_type;

#include <libaegis/output.h>
void t1_write(const output::pointer &fp, const char *name, t1_ty *value);
void t1_write_xml(const output::pointer &fp, const char *name, t1_ty *value);
t1_ty *t1_copy(t1_ty *);
t1_ty *t1_clone(t1_ty *);
#include <common/debug.h>
#ifndef t1_trace
#ifdef DEBUG
void t1_trace_real(const char *name, const t1_ty *value);
#define t1_trace(x) ((void)(trace_pretest_ && (trace_where_, t1_trace_real(trace_stringize(x), x), 0)))
#else
#define t1_trace(x)
#endif
#endif

#ifndef t2_DEF
#define t2_DEF
enum t2_ty
{
  t2_red,
  t2_green,
  t2_blue
};
#define t2_max 3
#endif // t2_DEF

extern meta_type t2_type;

void t2_write(const output::pointer &fp, const char *name, t2_ty value, bool show);
void t2_write_xml(const output::pointer &fp, const char *name, t2_ty value, bool show);
const char *t2_ename(t2_ty);
void t2__rpt_init(void);

#ifndef fred_first_list_DEF
#define fred_first_list_DEF
struct fred_first_list_ty
{
  size_t length;
  size_t maximum;
  long *list;
};
#endif // fred_first_list_DEF

extern meta_type fred_first_list_type;

fred_first_list_ty *fred_first_list_copy(fred_first_list_ty *);
fred_first_list_ty *fred_first_list_clone(fred_first_list_ty *);
void fred_first_list_write(const output::pointer &fp, const char *name, fred_first_list_ty *value);
void fred_first_list_write_xml(const output::pointer &fp, const char *name, fred_first_list_ty *value);
#ifndef fred_first_list_trace
#ifdef DEBUG
void fred_first_list_trace_real(const char *name, const fred_first_list_ty *value);
#define fred_first_list_trace(x) ((void)(trace_pretest_ && (trace_where_, fred_first_list_trace_real(trace_stringize(x), x), 0)))
#else
#define fred_first_list_trace(x)
#endif
#endif

#ifndef fred_DEF
#define fred_DEF

#define fred_first_mask ((unsigned long)0)
#define fred_f1_mask  ((unsigned long)0)
#define fred_f2_mask  ((unsigned long)1 << 0)

struct fred_ty
{
  long reference_count;
  unsigned long mask;
  string_ty *errpos;
  fred_first_list_ty *first;
  t1_ty *f1;
  t2_ty f2;
};
#endif // fred_DEF

extern meta_type fred_type;

void fred_write(const output::pointer &fp, fred_ty *value);
void fred_write_xml(const output::pointer &fp, fred_ty *value);
fred_ty *fred_copy(fred_ty *);
fred_ty *fred_clone(fred_ty *);
#ifndef fred_trace
#ifdef DEBUG
void fred_trace_real(const char *name, const fred_ty *value);
#define fred_trace(x) ((void)(trace_pretest_ && (trace_where_, fred_trace_real(trace_stringize(x), x), 0)))
#else
#define fred_trace(x)
#endif
#endif

/**
* The fred_write_file function is used to
* write fred meta data to the named file.
*
* @param filename
*     The name of the file to be written.
* @param value
*     The value of the meta-data to be written.
* @param comp
*     true (non-zero) if data should be compressed.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      will print a fatal error message, and
*      exit with an exit status of 1.
*/
void fred_write_file(string_ty *filename, fred_ty *value, int comp);
#include <common/nstring.h>

/**
* The fred_write_file function is used to
* write fred meta data to the named file.
*
* @param filnam
*     The name of the file to be written.
* @param value
*     The value of the meta-data to be written.
* @param comp
*     true if data should be compressed.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      will print a fatal error message, and
*      exit with an exit status of 1.
*/
void fred_write_file(const nstring &filnam, fred_ty *value, bool comp);

/**
* The fred_read_file function is used to
* read fred meta data from the named file.
*
* @param filename
*     The name of the file to be read.
* @returns
*     a pointer to a dynamically allocated
*     value read from the file.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      (including syntax errors) will print a
*      fatal error message, and exit with an
*      exit status of 1.
*/
fred_ty *fred_read_file(string_ty *filename);

/**
* The fred_read_file function is used to
* read fred meta data from the named file.
*
* @param filename
*     The name of the file to be read.
* @returns
*     a pointer to a dynamically allocated
*     value read from the file.
* @note
*      If any errors are encountered, this
*      function will not return.  All errors
*      (including syntax errors) will print a
*      fatal error message, and exit with an
*      exit status of 1.
*/
fred_ty *fred_read_file(const nstring &filename);
void fred__rpt_init(void);

#endif // FRED_H
fubar
if test $? -ne 0 ; then no_result; fi

#
# test the functionality
#
activity="fmtgen 749"
fmtgen -tw=2 fred.def -oc fred.cc -oi fred.h
if test $? -ne 0 ; then fail; fi

diff ok.cc fred.cc
if test $? -ne 0 ; then fail; fi

diff ok.h fred.h
if test $? -ne 0 ; then fail; fi

#
# Only definite negatives are possible.
# The functionality exercised by this test appears to work,
# no other guarantees are made.
#
pass
# vim: set ts=8 sw=4 et :
